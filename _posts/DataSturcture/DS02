---
layout: post
title: "[DS02]Array & LinkedList"
date: 2021-03-31
excerpt: "자료구조의 기초인 Array와 LinkedList에 대해서 다룹니다."
tags: [MLOps]
comments: False
use_math: true
---

이번 포스트부터는 본격적으로 자료구조들을 다뤄볼 예정입니다.Array를 시작으로 LinkedList까지 Computer Science 분야에서 숱하게 겪게되는 task와 관련지어 자료구조의 장단점을 돌아보는 방식으로 진행할 예정입니다.

## 1. Array
Array는 본격적인 자료 구조를 다룸에 있어서 가장 첫째로 나오는 것입니다. 우리가 "데이터를 어떻게 효과적으로 저장할 수 있을까"를 궁금해 한다면, 가장 단순한 방법으로는 순서대로 data를 특정한 틀 안에 담는 것이 좋을 것입니다.

Array는 이러한 배경하에 탄생하였기에, 각 데이터에 접근할 수 있는 index가 존재합니다. 그리고 이러한 index는 0부터 시작하여 n개의 데이터에 대해 n-1까지 붙게 됩니다.

처음 겪는 경우에는 혼동이 오기 쉬운데, n개의 데이터의 마지막 index는 n이 아닌 n-1이라는 것입니다.

이러한 방식의 좋은 점은 index를 통해 데이터에 접근하기 쉽다는 것입니다. 조금 더 비유적으로 생각해보자면, 우리가 50권의 책을 갖고있고 읽고싶은 책은 언제든 찾기로 합시다.
그렇다면 우리는 당연하게도 이 책을 1권부터 50권까지 숫자를 부여한 후 "책꽂이"에 정리할 것입니다. 그래야 편하게 찾을 수 있기 때문입니다.

따라서 index를 붙이는 것은 데이터에 효과적으로 접근할 수 있도록 도와줍니다.

게다가 Array는 한 가지 중요한 특성을 갖고 있는데, 바로 연속적인 데이터의 할당입니다. 따라서 인덱스를 알고 있을 때, 그 인덱스의 데이터를 얻는 데까지 걸리는 시간복잡도는 $O(1)$에 해당합니다.

그럼에도 이러한 Array는 단점을 가지고 있습니다. 삽입이나 삭제에서 매우 번거로워진다는 것입니다. 데이터가 연속적이게 할당되어 있으므로, 특정한 값을 삭제하거나 삽입하면 그에 맞게 다른 요소들을 다시 인덱스에 매핑해주어야 합니다.

worst case를 생각해보면, n개의 데이터가 존재할 때, Index 0에 새로운 값을 삽입하거나 추가한다고 가정할 수 있습니다. 이 때의 시간복잡도는 $O(n)$에 해당하며, 이러한 작업이 많은 경우에는 아주 비효율적인 자료구조에 해당할 것입니다.

정리를 하자면 다음의 2 가지를 기억하시면 됩니다.

* Access: $O(1)$
* Deletion/Addition: $O(n)$

이제 조금 다른 논의를 시작해봅시다.

앞서 책을 예시로 들어 언급할 때에, '책(Data)에 숫자(index)를 부여하여 책꽂이(Array)에 정리'하기로 약속했습니다. 그런데 이 책이 뒤죽박죽 섞여있다고 가정해봅시다. 그렇다면 아주 찾기 힘들어질 것입니다. 한편, 이러한 책이 순서대로 나열되어 있다고 생각하면 우리가 예를 들어 38권을 찾을 때 index가 37인 것에 접근하면 될 것입니다.

따라서, 우리는 책이 순서대로 나열되어 있을 때(sorted case)와 순서대로 나열되어 있지 않은 경우(unsorted case)를 나누어 생각해보아야 합니다.

## 2. Sorted case(Binary Search)
우선, 정렬되어 있는 배열의 경우입니다. 정렬되어 있다면 직관적으로 책을 찾기는 훨씬 쉬워질 것입니다. 우리가 9권을 찾고 있는데, 처음 책꽂이를 쳐다 본다고 상상해봅시다. 처음에 25권을 보았다면, 9권은 해당 책보다 앞에 있다고 확신할 수 있습니다. 이러한 방식으로 좁혀나가는 방법이 존재합니다.

우리는 모든 케이스를 커버하기 위해서 이러한 방식을 랜덤으로 탐색하지 않고 조금 체계적으로 정립할 필요가 있습니다. 바로 n개의 데이터에 대해 절반씩 조회를 하며 찾고자 하는 수가 이것보다 큰지 작은지를 비교하는 방식입니다. 이를 두고 Binary Search 알고리즘이라고 부릅니다.

Binary Search 알고리즘의 구체적인 논의는 세가지 포인터로 그 범위를 좁히며 맞게 탐색한 지에 대한 여부를 판단합니다. 세가지 포인터는 다음과 같습니다.
* left: 최초에 0으로 initialize
* right: 최초에 1로 initialize
* mid: 항상 (right+left)/2

위 아이디어를 바탕으로 코드를 조금 작성해봅시다.

~~~java

~~~

## 3. Unsorted case(Linear Search)


